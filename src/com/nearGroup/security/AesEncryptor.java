/*
 * Created on Jan 20, 2005
 *
 * TODO To change the template for this generated file go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
package com.nearGroup.security;

import java.security.GeneralSecurityException;
import java.security.InvalidKeyException;
import java.security.Provider;
import java.security.Security;
import java.util.Hashtable;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;


/**
 * @author dinoch
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
public class AesEncryptor {

	  Cipher AesCipher;
	  String PlainText; 
	  byte[] InitializationVector; 
	  //byte[] CipherText; 
	  SecretKeySpec KeySpec;

	  // NB: for debug only.  never store a key in plaintext! 
	  String _PassPhrase; 
	  
	  public AesEncryptor() throws Exception {
	  	//CreateCipher();
	  }

	  public AesEncryptor(String PassPhrase) throws Exception {
	  	//CreateCipher();
	  	setKey(PassPhrase);
	  }

	  public AesEncryptor(String PassPhrase, String ProviderName) throws Exception {
	  	setProvider(ProviderName); //implicitly call CreateCipher();
	  	setKey(PassPhrase);
	  }

	  public void setKey(String PassPhrase) {
	  	_PassPhrase= PassPhrase; 
	  	
	  	byte[] keyBytes= new byte[16];
	  	byte[] b= PassPhrase.getBytes();
	  	int len= b.length; 
	  	if (len > keyBytes.length) len = keyBytes.length;
	  	System.arraycopy(b, 0, keyBytes, 0, len);
	  	
	  	KeySpec = new SecretKeySpec(keyBytes, "AES");
	  }
	  
	  public byte[] getIv() {
  		//AesCipher.init(Cipher.ENCRYPT_MODE, KeySpec);	  	
	  	// retrieve the IV that was auto-generated by calling Cipher.init()
	  	InitializationVector= AesCipher.getIV();
	  	return InitializationVector; 
	  }
	  
	  public void setIv(byte[] iv) {
  		//AesCipher.init(Cipher.ENCRYPT_MODE, KeySpec);	  	
	  	// retrieve the IV that was auto-generated by calling Cipher.init()
	  	InitializationVector= new byte[16];
	  	System.arraycopy(iv, 0, InitializationVector, 0, 16);
	  	//System.out.println("InitializationVector:"+new String(InitializationVector));
	  }
	  
	  String _ProviderName;
	  public void setProvider(String provider) throws Exception {
	  	if (!provider.equals(_ProviderName)) {
	  	_ProviderName= provider;
	  	CreateCipher();
	  	}
	  }
	  public String getProvider() {return _ProviderName; }
	  
	  private void CreateCipher() throws Exception {
	  	if (!VerifyJceProvider()) throw new Exception("JCE Provider '" + _ProviderName + "' was not found."); 
	  	AesCipher = Cipher.getInstance("AES/CBC/PKCS5Padding", _ProviderName);
	    //System.out.println("cipher blocksize:  " + AesCipher.getBlockSize());
	  }

	  public byte[] Encrypt(String PlainText) throws Exception {

	    byte[] CipherText= Encrypt(PlainText.getBytes());    // ASCII encoding
	    getIv();
//	    System.out.println("  PlainText: "+ PlainText);
//	    System.out.println("Pass Phrase: "+ _PassPhrase);
//	    System.out.println("  key bytes: "+ FormatByteArray(KeySpec.getEncoded()));
//	    System.out.println("  IV length: "+ InitializationVector.length);
//	    System.out.println("         IV: "+ FormatByteArray(InitializationVector));
//	    System.out.println("  CT length: "+ CipherText.length);
//	    System.out.println(" CipherText: "+ FormatByteArray(CipherText));

	    return CipherText; 
	  }
	  
	  public byte[] Encrypt(byte[] PlainText) throws Exception {
	  	CreateCipher();
  		//AesCipher.init(Cipher.ENCRYPT_MODE, KeySpec);
	  	IvParameterSpec ivSpec = new IvParameterSpec(InitializationVector);
	  	AesCipher.init(Cipher.ENCRYPT_MODE, KeySpec, ivSpec);

	    return AesCipher.doFinal(PlainText);
	  }

	  public String DecryptToString(byte[] CipherText) throws Exception {

	  	byte[] decrypted= Decrypt(CipherText);
	  	String PlainText= new String(decrypted,"UTF-8"); // ascii encoding
	  	
/*	  	System.out.println("Pass Phrase: "+ _PassPhrase);
	  	System.out.println("  key bytes: "+ FormatByteArray(KeySpec.getEncoded()));
	  	System.out.println("  IV length: " + InitializationVector.length);
	  	System.out.println("         IV: " + FormatByteArray(InitializationVector));
	  	System.out.println("  CT length: " + CipherText.length);
	  	System.out.println(" CipherText: " + FormatByteArray(CipherText));
	  	System.out.println("  PlainText: " + PlainText );
*/	  	
	  	return PlainText;
	  }
	  
	  
	  public byte[] Decrypt(byte[] CipherText) throws Exception {
	 	CreateCipher();
	  	IvParameterSpec ivSpec = new IvParameterSpec(InitializationVector);
	  	AesCipher.init(Cipher.DECRYPT_MODE, KeySpec, ivSpec);
	  	byte[] decrypted;
	  	decrypted= AesCipher.doFinal(CipherText);
	  	
	  	//System.out.println("PlainText: " + FormatByteArray(original));
	  	return decrypted;
	  	}
	  	

	  public static String FormatByteArray(byte[] b) {
	    StringBuffer sb1= new StringBuffer();
	    for (int i = 0 ; i < b.length; i++) {
	       if (((int) b[i] & 0xff) < 0x10) sb1.append("0");
	       sb1.append(Long.toString((int) b[i] & 0xff, 16)).append(" ");
	    }
	    return sb1.toString();
	  }

	  
	  Hashtable CheckedJce= new Hashtable();
	  Hashtable HaveJce= new Hashtable();
	  
	  private boolean VerifyJceProvider() {
	  	
	  	// Check if provider  is installed., eg "IBMJCE", "SunJCE", "BC"
	  	if (!CheckedJce.containsKey(_ProviderName)) { 	  		
	  		if (Security.getProvider(_ProviderName) == null) {
	  			// Provider is not installed, try installing it.
	  			try {
	  				Security.addProvider
					((Provider)Class.forName(_ProviderName).newInstance());
	  				CheckedJce.put(_ProviderName, new Boolean(true)); 
	  				HaveJce.put(_ProviderName, new Boolean(true));
	  			}
	  			catch (Exception ex) {
	  				//System.out.println("Cannot install provider: " + ex.getMessage());
	  				CheckedJce.put(_ProviderName, new Boolean(true)); 
	  				HaveJce.put(_ProviderName, new Boolean(false));
	  			}
	  		}
	  		else {
  				CheckedJce.put(_ProviderName, new Boolean(true)); 
  				HaveJce.put(_ProviderName, new Boolean(true));
	  		}
	  	}
	  	return ((Boolean) HaveJce.get(_ProviderName)).booleanValue();
	}

}
